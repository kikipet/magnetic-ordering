model_kwargs for GatedConvParityNetwork = {
    "convolution": Convolution,
    "kernel": Kernel,
    "Rs_in": Rs_in, # input representation
    "Rs_out": Rs_out, # output representation
    "mul": params['num_channel_irrep'], # number of channels per irrep (differeing L and parity)
    "layers": params['num_e3nn_layer'],
    "max_radius": params['max_radius'],
    "lmax": lmax,
    "number_of_basis": params['num_basis']
}


data.append(DataPeriodicNeighbors(
            x=input, Rs_in=None, 
            pos=torch.tensor(struct.cart_coords.copy()), 
            lattice=torch.tensor(struct.lattice.matrix.copy()),
            r_max=params['max_radius'],
            y = (torch.tensor([y_values[i]])).to(torch.long),
            n_norm=n_norm,
        ))


"""
    x (torch.Tensor shape [N, M]): per-node M-dimensional features.
    pos (torch.Tensor shape [N, 3]): node positions.
    r_max (float): neighbor cutoff radius.
    cell (ase.Cell/ndarray [3,3], optional): cell (box) for the points. Defaults to ``None``.
    pbc (bool or 3-tuple of bool, optional): whether to apply periodic boundary conditions to all or each of the three cell vector directions. Defaults to ``False``.
    self_interaction (bool, optional): whether to include self edges for points. Defaults to ``True``.
    **kwargs (optional): other attributes to pass to the ``torch_geometric.data.Data`` constructor.
"""
    def __init__(self, x, pos, r_max, cell=None, pbc=False, self_interaction=True, **kwargs):
        edge_index, edge_attr = _neighbor_list_and_relative_vec(
            pos,
            r_max,
            self_interaction=self_interaction,
            cell=cell,
            pbc=pbc
        )
        if cell is not None:
            # For compatability: the old DataPeriodicNeighbors put the cell
            # in the Data object as `lattice`.
            kwargs['lattice'] = cell
        super().__init__(x=x, edge_index=edge_index, edge_attr=edge_attr, pos=pos, **kwargs)

    @classmethod
    def from_ase(cls, atoms, r_max, features=None, **kwargs):
        """Build a ``DataNeighbors`` from an ``ase.Atoms`` object.
        Respects ``atoms``'s ``pbc`` and ``cell``.
        Args:
            atoms (ase.Atoms): the input.
            r_max (float): neighbor cutoff radius.
            features (torch.Tensor shape [N, M], optional): per-atom M-dimensional feature vectors. If ``None`` (the default), uses a one-hot encoding of the species present in ``atoms``.
            **kwargs (optional): other arguments for the ``DataNeighbors`` constructor.
        Returns:
            A ``DataNeighbors``.
        """
        if features is None:
            _, species_ids = np.unique(atoms.get_atomic_numbers(), return_inverse=True)
            features = torch.nn.functional.one_hot(torch.as_tensor(species_ids)).to(dtype=torch.get_default_dtype())
        return cls(
            x=features,
            pos=torch.as_tensor(atoms.positions),
            r_max=r_max,
            cell=atoms.get_cell(),
            pbc=atoms.pbc,
            **kwargs
        )


class DataPeriodicNeighbors(DataNeighbors):
    """Compatability wrapper for ``DataNeighbors``.
    Arguments are the same as ``DataNeighbors``, but ``lattice`` is accepted
    as an alias for ``cell`` and ``pbc`` is always set to ``True``.
    """
    def __init__(self, x, pos, lattice, r_max, self_interaction=True, **kwargs):
        super().__init__(
            x=x, pos=pos, cell=lattice, pbc=True, r_max=r_max,
            self_interaction=self_interaction, **kwargs
        )
